import sc.bind.Bindable;
import sc.bind.Bind;
import sc.lang.java.BodyTypeDeclaration;
import sc.lang.java.JavaModel;
import sc.layer.Layer;
import sc.layer.LayeredSystem;
import sc.layer.SrcEntry;

import java.util.ArrayList;

import java.util.*;

import sc.obj.Constant;
import sc.obj.Sync;
import sc.obj.SyncMode;

import sc.type.CTypeUtil;

/** This is the part of the editor context we share on the client. It's a workaround for the fact that we don't depend on the modify operator to build SC (so the IDE can build it directly) */
@Sync(onDemand=true)
public class ClientEditorContext {
   @Constant
   public LayeredSystem system;

   JavaModel pendingModel = null;
   LinkedHashSet<JavaModel> changedModels = new LinkedHashSet<JavaModel>();
   LinkedHashMap<SrcEntry, Object> errorModels = new LinkedHashMap<SrcEntry, Object>();

   ArrayList<BodyTypeDeclaration> currentTypes = new ArrayList<BodyTypeDeclaration>();

   @Sync(syncMode=SyncMode.Disabled)
   boolean currentModelStale = false;

   public Layer currentLayer;

   public List<Layer> currentLayers = new sc.util.ArrayList<Layer>(1);

   public String layerPrefix;

   HashMap<SrcEntry,MemoryEditSession> memSessions = new HashMap<SrcEntry, MemoryEditSession>();

   private List<String> createInstTypeNames;

   private boolean memorySessionChanged = false;
   @Sync(syncMode=SyncMode.Disabled)
   @Bindable(manual=true)
   public boolean getMemorySessionChanged() {
      return memorySessionChanged;
   }

   public void setMemorySessionChanged(boolean val) {
      memorySessionChanged = val;
      Bind.sendChangedEvent(this, "memorySessionChanged");
   }

   @Bindable(manual=true)
   public List<String> getCreateInstTypeNames() {
      return createInstTypeNames;
   }

   public void setCreateInstTypeNames(List<String> nl) {
      createInstTypeNames = nl;
      Bind.sendChangedEvent(this, "createInstTypeNames");
   }

   public boolean isCreateInstType(String typeName) {
      return createInstTypeNames != null && createInstTypeNames.contains(typeName);
   }

   public String getCreateInstFullTypeName(String typeName) {
      for (String tn:createInstTypeNames)
         if (CTypeUtil.getClassName(tn).equals(typeName))
            return tn;
      return null;
   }
   public void updateCurrentLayer(Layer l) {
      currentLayer = l;
      currentLayers = l.getSelectedLayers();
   }

   public void addCurrentLayer(Layer l) {
      if (currentLayers == null)
         updateCurrentLayer(l);
      else {
         for (int i = 0; i < currentLayers.size(); i++) {
            Layer current = currentLayers.get(i);
            if (current == l)
               return;
            if (current.layerPosition > l.layerPosition) {
               currentLayers.add(i, l);
               return;
            }
         }
         currentLayers.add(l);
      }
   }

   @Bindable(manual=true)
   public void setCurrentLayer(Layer newLayer) {
      // TODO: should we try to preserve imports here and only switch the layer of the pending model if there's no type?
      if (currentLayer != newLayer) {
         updateCurrentLayer(newLayer);
         if (currentLayer != null)
            layerPrefix = currentLayer.packagePrefix;
         else
            layerPrefix = null;
         Bind.sendChangedEvent(this, "currentLayer");
         Bind.sendChangedEvent(this, "currentLayers");
      }
   }
}

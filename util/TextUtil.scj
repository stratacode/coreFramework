import java.text.DecimalFormat;
import java.util.Map;

@sc.js.JSSettings(jsLibFiles="js/util.js", prefixAlias="sc_")
public class TextUtil {
   // Accepts any Number including BigDecimal for symmetric formatting on server and client
   public static String format(String format, Object number) {
      DecimalFormat df = new DecimalFormat(format);
      return df.format(number);
   }

   // Currently the data binding system can't listen on method calls but can for function arguments so this is a workaround
   public static int length(String str) {
      if (str == null)
         return 0;
      return str.length();
   }

   public static boolean isEmpty(String str) {
      return str == null || str.length() == 0;
   }

   public static boolean equals(CharSequence s1, CharSequence s2) {
      if (s1 == s2)
         return true;
      if (s1 == null || s2 == null)
         return false;
      int s1len = s1.length();
      int s2len = s2.length();
      if (s1len != s2len)
         return false;
      for (int i = 0; i < s1len; i++) {
         if (s1.charAt(i) != s2.charAt(i))
            return false;
      }
      return true;
   }

   public static String escapeHTML(String in) {
      return StringUtil.escapeHTML(in, false).toString();
   }

   public static String escapeQuotes(String in) {
      return in.replace("'","&apos;").replace("\"", "&quot;");
   }

   private final static String allowedEmailChars = "+_!%#$&'*/=^`{}|~;";

   public static String validateEmailAddress(String emailAddress) {
      if (emailAddress == null || emailAddress.length() == 0)
         return "Empty email address";
      if (emailAddress.length() > 256)
         return "Email address is too long";

      int atIx = emailAddress.indexOf('@');
      if (atIx == -1 || emailAddress.length() - atIx < 5)
         return "Email address invalid";
      String local = emailAddress.substring(0, atIx);
      String domain = emailAddress.substring(atIx+1);
      int lastDot = -1;
      int i;
      int localLen = local.length();
      boolean quoted = false;
      for (i = 0; i < localLen; i++) {
         char l = local.charAt(i);
         if (l == '.') {
            if (i == 0 || i == localLen - 1)
               break;
            if (lastDot == i - 1)
               break;
            lastDot = l;
         }
         else if (l == '-') {
            if (i == 0 || i == localLen - 1)
               break;
         }
         else if (l == '"') {
            if (i == 0)
               quoted = true;
            else if (quoted && l != localLen - 1)
               break;
         }
         else if (Character.isWhitespace(l)) {
            if (!quoted)
              break;
         }
         else if (!Character.isLetterOrDigit(l)) {
            if (allowedEmailChars.indexOf(l) == -1)
               break;
         }
      }
      if (i != localLen)
         return "Invalid email name: expected name@server.domain";

      int domainLen = domain.length();
      boolean foundDot = false;
      for (i = 0; i < domainLen; i++) {
         char d = domain.charAt(i);
         if (d == '.') {
            if (i == domainLen - 1)
               break;
            foundDot = true;
         }
         else if (!Character.isLetterOrDigit(d) && d != '-')
            break;
      }
      if (i != domainLen || !foundDot)
         return "Invalid email server: expected name@server.domain";
      return null;
   }

   public static boolean hasMapEntry(Map<String,String> map, String key) {
      return map != null && map.containsKey(key);
   }

}
